<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Shakrit - Side Scroller Level Demo</title>
<style>
  html,body{height:100%;margin:0;background:#071018;color:#fff;font-family:Inter, "Segoe UI", Roboto, Arial}
  #title{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;flex-direction:column;z-index:60;background:linear-gradient(#000A10, rgba(0,0,0,0.7))}
  h1{margin:0 0 12px 0;font-size:48px;color:#00ff99;text-shadow:0 6px 18px rgba(0,0,0,0.7)}
  .btn{background:#122; border:1px solid rgba(255,255,255,0.06); color:#fff; padding:12px 22px;border-radius:8px;cursor:pointer;margin:6px}
  #canvasWrap{display:flex;justify-content:center;align-items:center;height:100vh;padding:12px;box-sizing:border-box}
  canvas{background:linear-gradient(#071018,#021015);border:3px solid rgba(255,255,255,0.04);max-width:100%;height:auto;display:block}
  #hud{position:fixed;left:12px;top:12px;display:flex;gap:12px;z-index:80}
  .panel{background:rgba(0,0,0,0.45);padding:8px 12px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);font-weight:700}
  #controls{position:fixed;left:0;right:0;bottom:14px;display:flex;justify-content:space-between;padding:0 20px;z-index:80;pointer-events:none}
  .leftControls,.rightControls{display:flex;gap:12px;pointer-events:auto}
  .ctrl{width:64px;height:64px;border-radius:12px;background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.05);display:flex;align-items:center;justify-content:center;font-size:22px}
  .ctrl.big{width:92px;height:72px}
  #pauseOverlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:90;background:rgba(0,0,0,0.6)}
  #pauseOverlay .box{background:#071018;border:1px solid rgba(255,255,255,0.04);padding:18px;border-radius:10px;text-align:center}
  @media(max-width:600px){ .ctrl{width:52px;height:52px;font-size:18px} .ctrl.big{width:84px;height:64px} h1{font-size:36px} }
</style>
</head>
<body>

<!-- Title -->
<div id="title">
  <h1>Shakrit — Level Demo</h1>
  <div>
    <button id="startBtn" class="btn">Play</button>
    <button id="resetBtn" class="btn">Reset</button>
  </div>
  <div style="margin-top:10px;color:#9fb">Controls: Arrow keys / Space = jump / Z = shoot • Touch controls shown below</div>
</div>

<!-- HUD -->
<div id="hud" aria-hidden>
  <div class="panel" id="score">Score: 0</div>
  <div class="panel" id="lives">Lives: 3</div>
  <div class="panel" id="pos">X: 0</div>
</div>

<!-- Canvas -->
<div id="canvasWrap">
  <canvas id="c" width="1100" height="540"></canvas>
</div>

<!-- Controls -->
<div id="controls">
  <div class="leftControls">
    <div id="btnLeft" class="ctrl">◀</div>
    <div id="btnRight" class="ctrl">▶</div>
    <div id="btnJump" class="ctrl">▲</div>
  </div>
  <div class="rightControls">
    <div id="btnFire" class="ctrl big">FIRE</div>
  </div>
</div>

<!-- Pause overlay -->
<div id="pauseOverlay"><div class="box"><h2>Paused</h2><div style="margin-top:10px"><button id="resumeBtn" class="btn">Resume</button></div></div></div>

<script>
/* ========== Side-scroller level engine ========== */
/* Behavior summary:
   - There is a levelWidth. Player moves; camera follows.
   - Enemies are defined in levelData, each with x, patrolRange (left/right bounds), triggerX (when to activate).
   - Enemy activates only when player.x >= (triggerX - triggerMargin).
   - Active enemies patrol inside their own patrol min/max and shoot at cooldown when player in detection range.
   - Fewer active enemies at once; enemies don't instantly converge on the player.
*/

/* --------- Setup --------- */
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W = canvas.width, H = canvas.height;

// DOM
const title = document.getElementById('title');
const startBtn = document.getElementById('startBtn');
const resetBtn = document.getElementById('resetBtn');
const scoreDOM = document.getElementById('score');
const livesDOM = document.getElementById('lives');
const posDOM = document.getElementById('pos');
const pauseOverlay = document.getElementById('pauseOverlay');
const resumeBtn = document.getElementById('resumeBtn');

// Controls
const btnLeft = document.getElementById('btnLeft');
const btnRight = document.getElementById('btnRight');
const btnJump = document.getElementById('btnJump');
const btnFire = document.getElementById('btnFire');

// Game state
let running = false;
let paused = false;
let cameraX = 0;
const levelWidth = 5000; // pixel length of the level
let score = 0;
let lives = 3;

// Player
const player = {
  x: 80, y: H - 120, w:44, h:64,
  vx:0, vy:0, speed:4.2,
  onGround:true, facing:'right', shootCooldown:0
};

// Active entities
let activeEnemies = [];   // enemies that are spawned/active
let enemyBullets = [];    // enemy bullets
let bullets = [];         // player bullets
let particles = [];

// Input
const input = { left:false, right:false, up:false, shoot:false };

// Level definition: enemy zones with positions and patrol ranges.
// Each object: { id, x, y, patrolRange, triggerX, type, ... }
// triggerX determines when enemy becomes active (player.x >= triggerX - margin)
const levelData = [
  // stage 1: a few well spaced enemies
  { id:1, x:600, y:H-120, patrolRange:120, triggerX:550, type:'grunt', hp:2, shootRange:220 },
  { id:2, x:950, y:H-120, patrolRange:100, triggerX:900, type:'grunt', hp:2, shootRange:220 },
  { id:3, x:1400, y:H-120, patrolRange:180, triggerX:1360, type:'jumper', hp:3, shootRange:260 },
  { id:4, x:2000, y:H-120, patrolRange:200, triggerX:1960, type:'grunt', hp:2, shootRange:240 },
  { id:5, x:2600, y:H-120, patrolRange:220, triggerX:2560, type:'grunt', hp:2, shootRange:200 },
  { id:6, x:3200, y:H-120, patrolRange:320, triggerX:3160, type:'sniper', hp:2, shootRange:420 },
  // mini-boss later
  { id:7, x:3800, y:H-220, patrolRange:160, triggerX:3760, type:'mini-boss', hp:18, shootRange:320 },
  { id:8, x:4400, y:H-120, patrolRange:140, triggerX:4360, type:'grunt', hp:2, shootRange:220 }
];

// Max active enemies at once to avoid overwhelm
const MAX_ACTIVE = 3;
const TRIGGER_MARGIN = 80;

// Utility
function rand(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }
function clamp(a,b,c){ return Math.max(b,Math.min(c,a)); }
function rects(a,b){ return !(a.x+a.w < b.x || a.x > b.x+b.w || a.y+a.h < b.y || a.y > b.y+b.h); }

/* --------- Spawn / activation logic --------- */
let levelIndex = 0;

// track which levelData entries are activated
const activated = new Set();

function tryActivateEnemies(){
  // activate in order: find entries where player.x >= triggerX - TRIGGER_MARGIN
  for(let i=0;i<levelData.length;i++){
    const cfg = levelData[i];
    if(activated.has(cfg.id)) continue;
    if(player.x >= cfg.triggerX - TRIGGER_MARGIN){
      // only activate if under MAX_ACTIVE
      if(activeEnemies.length < MAX_ACTIVE){
        spawnEnemyFromCfg(cfg);
        activated.add(cfg.id);
      }
      // even if MAX_ACTIVE reached, keep cfg inactivated — we will check again next tick
    }
  }
}

// convert cfg into active enemy instance
function spawnEnemyFromCfg(cfg){
  const e = {
    id: cfg.id,
    type: cfg.type,
    x: cfg.x,
    y: cfg.y,
    baseX: cfg.x,
    patrolRange: cfg.patrolRange,
    minX: cfg.x - cfg.patrolRange/2,
    maxX: cfg.x + cfg.patrolRange/2,
    w:44, h:48,
    vx: (Math.random()<0.5? -1:1) * (0.6 + Math.random()*1.2),
    vy:0,
    hp: cfg.hp,
    shootRange: cfg.shootRange,
    shootCooldown: rand(40,160), // frames
    state:'patrol' // states: patrol, idle
  };
  // clamp patrol bounds into level
  e.minX = Math.max(50, e.minX);
  e.maxX = Math.min(levelWidth - 50, e.maxX);
  activeEnemies.push(e);
}

/* --------- Update loop --------- */
let last = 0;
function loop(ts){
  if(!last) last = ts;
  const dt = (ts-last)/16.666; last = ts;
  if(running && !paused){
    update(dt);
    render();
  }
  requestAnimationFrame(loop);
}

/* Update everything */
function update(dt){
  // camera follows player (center-ish)
  const viewCenter = W * 0.4;
  // move player by input
  player.vx = 0;
  if(input.left) player.vx = -player.speed;
  if(input.right) player.vx = player.speed;
  player.x += player.vx;
  // clamp player inside world
  player.x = clamp(player.x, 12, levelWidth - player.w - 12);

  // camera follow: move cameraX so player sits near left-center
  cameraX = clamp(player.x - viewCenter, 0, levelWidth - W);

  // jumping
  if(input.up && player.onGround){ player.vy = -11.5; player.onGround=false; }
  player.vy += 0.6; player.y += player.vy;
  if(player.y + player.h >= H - 20){ player.y = H - 20 - player.h; player.vy = 0; player.onGround = true; }

  // shooting: single press behavior handled in input handler; cooldown
  if(input.shoot && player.shootCooldown <= 0){
    const dir = player.facing === 'right' ? 1 : -1;
    bullets.push({ x: player.x + (dir===1?player.w: -12), y: player.y + player.h*0.45, vx: 12*dir, w:10, h:5, life:200 });
    player.shootCooldown = 12; // frames
  }
  if(player.shootCooldown>0) player.shootCooldown--;

  // Activate enemies when player reaches triggers, mindful of MAX_ACTIVE
  tryActivateEnemies();

  // Update active enemies
  for(let i=activeEnemies.length-1;i>=0;i--){
    const e = activeEnemies[i];
    // basic patrol: move and reverse at bounds
    e.x += e.vx;
    if(e.x < e.minX){ e.x = e.minX; e.vx = Math.abs(e.vx); }
    if(e.x + e.w > e.maxX){ e.x = e.maxX - e.w; e.vx = -Math.abs(e.vx); }
    // small vertical movement for jumpers
    if(e.type === 'jumper' && Math.random() < 0.006){ e.vy = -9 - Math.random()*4; }
    e.vy = (e.vy||0) + 0.5;
    e.y += e.vy;
    if(e.y + e.h >= H - 20){ e.y = H - 20 - e.h; e.vy = 0; }

    // detect player and shoot if in range
    const dx = (player.x - e.x);
    const dist = Math.abs(dx);
    if(dist <= e.shootRange && e.shootCooldown <= 0){
      // enemy shoots towards player (but not too often)
      const dir = dx >= 0 ? 1 : -1;
      enemyBullets.push({ x: e.x + e.w/2, y: e.y + e.h/2, vx: dir*5, vy: 0, w:8, h:6, life:300 });
      e.shootCooldown = 70 + Math.floor(Math.random()*80) - Math.floor(gameDifficulty()*20); // variability + difficulty
    }
    if(e.shootCooldown>0) e.shootCooldown--;

    // enemy limited behavior: if hp<=0 remove & spawn explosion and maybe powerup
    if(e.hp <= 0){
      spawnParticles(e.x + e.w/2 - 6, e.y + e.h/2 - 6, 14);
      score += (e.type==='mini-boss' ? 300 : 40);
      activeEnemies.splice(i,1);
      updateHUD();
      continue;
    }
  }

  // bullets update (player bullets)
  for(let i=bullets.length-1;i>=0;i--){
    const b = bullets[i];
    b.x += b.vx;
    b.life--;
    if(b.life<=0 || b.x < -50 || b.x > levelWidth + 50) bullets.splice(i,1);
    else {
      // check collision with active enemies (local coordinates)
      for(let j=activeEnemies.length-1;j>=0;j--){
        const e = activeEnemies[j];
        if(rects(b, e)){
          e.hp -= 1;
          bullets.splice(i,1);
          break;
        }
      }
    }
  }

  // enemy bullets update & collision with player
  for(let i=enemyBullets.length-1;i>=0;i--){
    const b = enemyBullets[i];
    b.x += b.vx; b.y += b.vy; b.life--;
    if(b.life<=0 || b.x < -50 || b.x > levelWidth + 50) enemyBullets.splice(i,1);
    else if(rects(b, player)){
      enemyBullets.splice(i,1);
      hurtPlayer();
    }
  }

  // particles update
  for(let i=particles.length-1;i>=0;i--){
    const p = particles[i];
    p.x += p.vx; p.y += p.vy; p.vy += 0.25; p.life--;
    if(p.life <= 0) particles.splice(i,1);
  }

  // minor enemy spawn flood-control: if activeEnemies < MAX_ACTIVE, try to activate more cfgs
  if(activeEnemies.length < MAX_ACTIVE){
    for(let i=0;i<levelData.length;i++){
      const cfg = levelData[i];
      if(!activated.has(cfg.id) && player.x >= cfg.triggerX - TRIGGER_MARGIN){
        spawnEnemyFromCfg(cfg);
        activated.add(cfg.id);
        break;
      }
    }
  }

  updateHUD();
}

/* --------- Render everything with cameraX offset --------- */
function render(){
  // clear
  ctx.fillStyle = '#081018';
  ctx.fillRect(0,0,W,H);

  // parallax sky
  ctx.fillStyle = '#052227';
  ctx.fillRect(0,0,W, H-140);

  // distant hills (parallax)
  ctx.fillStyle = '#033e31';
  for(let i=0;i<6;i++){
    const hx = ((i*500 - cameraX*0.2) % (levelWidth)) - cameraX*0.02;
    ctx.beginPath();
    ctx.ellipse(hx + 200, H-140, 420, 80, 0, 0, Math.PI*2);
    ctx.fill();
  }

  // ground
  ctx.fillStyle = '#142b2a';
  ctx.fillRect(0, H-20, W, 20);

  // draw level objects relative to camera
  // draw a simple debug grid for level progression
  ctx.fillStyle = 'rgba(255,255,255,0.02)';
  for(let gx=0; gx<levelWidth; gx+=200){
    const sx = gx - cameraX;
    ctx.fillRect(sx, H-22, 2, 14);
  }

  // draw enemies
  for(const e of activeEnemies){
    const ex = e.x - cameraX, ey = e.y;
    // body
    ctx.fillStyle = (e.type==='mini-boss')? '#993344' : '#e25b5b';
    ctx.fillRect(ex, ey, e.w, e.h);
    // HP bar for mini-boss
    if(e.type === 'mini-boss'){
      ctx.fillStyle = '#222';
      ctx.fillRect(ex, ey-8, e.w, 6);
      const pct = e.hp / 18;
      ctx.fillStyle = '#00ff99';
      ctx.fillRect(ex, ey-8, e.w * pct, 6);
    }
  }

  // draw bullets
  ctx.fillStyle = '#ffd24d';
  for(const b of bullets){ ctx.fillRect(b.x - cameraX, b.y, b.w, b.h); }

  ctx.fillStyle = '#ff7b7b';
  for(const b of enemyBullets){ ctx.fillRect(b.x - cameraX, b.y, b.w, b.h); }

  // draw player
  drawPlayer(player.x - cameraX, player.y, player.w, player.h, player.facing);

  // particles
  for(const p of particles){ ctx.fillStyle = p.col; ctx.fillRect(p.x - cameraX, p.y, 3,3); }
}

/* Simple player drawing (no images) */
function drawPlayer(sx, sy, w, h, facing){
  // torso
  ctx.fillStyle = '#00b07a';
  ctx.fillRect(sx, sy, w, h);
  // helmet
  ctx.fillStyle = '#023d2b';
  ctx.fillRect(sx, sy, w, Math.floor(h*0.28));
  // gun
  ctx.fillStyle = '#2b2b2b';
  if(facing === 'right'){
    ctx.fillRect(sx + w, sy + Math.floor(h*0.34), Math.floor(w*0.9), Math.floor(h*0.18));
  } else {
    ctx.fillRect(sx - Math.floor(w*0.9), sy + Math.floor(h*0.34), Math.floor(w*0.9), Math.floor(h*0.18));
  }
}

/* spawn simple particles used for death/explosion */
function spawnParticles(cx, cy, n){
  for(let i=0;i<n;i++){
    particles.push({ x:cx + rand(-8,8), y:cy + rand(-8,8), vx:(Math.random()-0.5)*6, vy:(Math.random()-0.8)*6, life:30 + rand(0,40), col: ['#ff9a6b','#ff6b6b','#ffd24d'][rand(0,2)] });
  }
}

/* player hurt */
function hurtPlayer(){
  lives = Math.max(0, lives - 1);
  // small explosion
  spawnParticles(player.x + player.w/2, player.y + player.h/2, 12);
  // respawn slightly behind
  player.x = Math.max(80, player.x - 120);
  player.vx = 0; player.vy = 0;
  updateHUD();
  if(lives <= 0){
    paused = true;
    alert('Game Over! Score: ' + score);
    // reset
    resetGame();
  }
}

/* update HUD DOM */
function updateHUD(){
  scoreDOM.textContent = 'Score: ' + score;
  livesDOM.textContent = 'Lives: ' + lives;
  posDOM.textContent = 'X: ' + Math.floor(player.x);
}

/* input handlers (keyboard) */
window.addEventListener('keydown', (e)=>{
  if(e.key === 'ArrowLeft') { input.left = true; player.facing='left'; }
  if(e.key === 'ArrowRight') { input.right = true; player.facing='right'; }
  if(e.key === ' ' || e.key === 'ArrowUp') input.up = true;
  if(e.key.toLowerCase() === 'z') { input.shoot = true; }
  if(e.key.toLowerCase() === 'p') { paused = !paused; pauseOverlay.style.display = paused ? 'flex' : 'none'; }
});
window.addEventListener('keyup', (e)=>{
  if(e.key === 'ArrowLeft') input.left = false;
  if(e.key === 'ArrowRight') input.right = false;
  if(e.key === ' ' || e.key === 'ArrowUp') input.up = false;
  if(e.key.toLowerCase() === 'z') input.shoot = false;
});

/* touch wiring for on-screen buttons */
function wireTouch(el, action){
  el.addEventListener('touchstart', (ev)=>{ ev.preventDefault(); if(action==='left') input.left=true; if(action==='right') input.right=true; if(action==='jump') input.up=true; if(action==='shoot'){ input.shoot=true; } }, {passive:false});
  el.addEventListener('touchend', (ev)=>{ ev.preventDefault(); if(action==='left') input.left=false; if(action==='right') input.right=false; if(action==='jump') input.up=false; if(action==='shoot'){ input.shoot=false; } }, {passive:false});
  // mouse support for convenience
  el.addEventListener('mousedown', ()=>{ if(action==='left') input.left=true; if(action==='right') input.right=true; if(action==='jump') input.up=true; if(action==='shoot') input.shoot=true; });
  el.addEventListener('mouseup', ()=>{ if(action==='left') input.left=false; if(action==='right') input.right=false; if(action==='jump') input.up=false; if(action==='shoot') input.shoot=false; });
  el.addEventListener('mouseleave', ()=>{ if(action==='left') input.left=false; if(action==='right') input.right=false; if(action==='jump') input.up=false; if(action==='shoot') input.shoot=false; });
}
wireTouch(btnLeft, 'left'); wireTouch(btnRight, 'right'); wireTouch(btnJump, 'jump'); wireTouch(btnFire, 'shoot');

/* start / reset / pause */
function resetGame(){
  // reset core variables
  running = false;
  paused = false;
  cameraX = 0;
  score = 0;
  lives = 3;
  player.x = 80; player.y = H - 120; player.vx=0; player.vy=0; player.onGround=true; player.shootCooldown=0;
  activeEnemies.length = 0;
  bullets.length = 0;
  enemyBullets.length = 0;
  particles.length = 0;
  activated.clear();
  updateHUD();
}
resetBtn.onclick = ()=> { resetGame(); title.style.display='flex'; canvas.style.display='block'; }

// resume button
resumeBtn.onclick = ()=>{ paused=false; pauseOverlay.style.display='none'; }

/* start button (hide title and start loop) */
startBtn.onclick = ()=>{
  title.style.display = 'none';
  canvas.style.display = 'block';
  running = true; paused = false;
  // pre-activate first enemy a little earlier so player sees something but not flood
  // leave others inactive until player reaches them
  requestAnimationFrame(loop);
};

/* helper: gameDifficulty increases pace as level increases */
function gameDifficulty(){ return 1 + (Math.floor(score/500) * 0.15); }

/* initial setup */
const activated = new Set();
updateHUD();
requestAnimationFrame(loop);

</script>
</body>
</html>
