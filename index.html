<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>
<title>Shakrit — Contra Inspired</title>
<style>
  :root{--bg:#0b0b12;--panel:#0f1720;--accent:#00e676;--danger:#ff5252;--muted:#9aa4b2}
  html,body{height:100%;margin:0;font-family:Inter, system-ui, -apple-system, Roboto, Arial;background:var(--bg);color:#fff}
  #title {position:fixed;inset:0;display:flex;flex-direction:column;justify-content:center;align-items:center;z-index:60;background:linear-gradient(180deg, rgba(0,0,0,0.75), rgba(0,0,0,0.9))}
  #title h1{font-size:72px;margin:0;color:var(--accent);text-shadow:0 6px 20px rgba(0,0,0,0.8)}
  #title .subtitle{color:var(--muted);margin:10px 0 24px}
  .btn{background:#111;border:2px solid #333;color:#fff;padding:12px 22px;border-radius:8px;margin:6px;font-size:18px;cursor:pointer}
  .btn.primary{background:linear-gradient(90deg,#081219,#0a2a1a);border-color:var(--accent);box-shadow:0 6px 18px rgba(0,230,118,0.06)}
  .small{font-size:14px;padding:8px 12px}
  #hud{position:fixed;left:14px;top:12px;z-index:50;display:flex;gap:12px;align-items:center}
  #hud .panel{background:rgba(0,0,0,0.4);padding:8px 12px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);font-weight:600}
  #canvasWrap{width:100%;height:calc(100vh);display:flex;justify-content:center;align-items:center;padding:18px;box-sizing:border-box}
  canvas{background:linear-gradient(#071018,#0b1720);border:4px solid rgba(255,255,255,0.06);max-width:100%;height:auto;display:block}
  #controls{position:fixed;left:0;right:0;bottom:12px;display:flex;justify-content:space-between;z-index:55;pointer-events:none;padding:0 20px}
  .leftControls,.rightControls{display:flex;gap:10px;pointer-events:auto}
  .ctrl{width:68px;height:68px;border-radius:12px;background:rgba(0,0,0,0.55);border:2px solid rgba(255,255,255,0.06);display:flex;align-items:center;justify-content:center;font-size:22px;color:#fff;user-select:none;touch-action:none}
  .ctrl.big{width:90px;height:90px;font-size:20px;border-radius:14px}
  #pauseOverlay{position:fixed;inset:0;background:rgba(0,0,0,0.6);display:none;z-index:70;justify-content:center;align-items:center;flex-direction:column}
  #pauseOverlay .panel{background:var(--panel);padding:18px;border-radius:10px;border:1px solid rgba(255,255,255,0.04);text-align:center}
  #settingsModal{position:fixed;right:18px;top:18px;background:var(--panel);padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.04);z-index:70}
  #fps{position:fixed;right:18px;bottom:18px;background:rgba(0,0,0,0.5);padding:6px 10px;border-radius:8px;font-size:13px;z-index:70}
  /* small screens */
  @media (max-width:700px){
    #title h1{font-size:44px}
    .ctrl{width:56px;height:56px;font-size:18px}
    .ctrl.big{width:78px;height:78px}
  }
</style>
</head>
<body>

<!-- Title screen -->
<div id="title">
  <h1>Shakrit</h1>
  <div class="subtitle">A Contra-inspired web game — playable on mobile</div>
  <div>
    <button id="startBtn" class="btn primary">Play</button>
    <button id="settingsBtn" class="btn small">Settings</button>
    <button id="creditsBtn" class="btn small">Credits</button>
  </div>
</div>

<!-- HUD -->
<div id="hud" aria-hidden>
  <div class="panel" id="scorePanel">Score: 0</div>
  <div class="panel" id="lifePanel">Lives: 3</div>
  <div class="panel" id="levelPanel">Level: 1</div>
</div>

<!-- Canvas area -->
<div id="canvasWrap">
  <canvas id="game" width="960" height="540"></canvas>
</div>

<!-- Controls -->
<div id="controls">
  <div class="leftControls">
    <div id="btnLeft" class="ctrl">◀</div>
    <div id="btnRight" class="ctrl">▶</div>
    <div id="btnJump" class="ctrl">▲</div>
  </div>
  <div class="rightControls">
    <div id="btnFire1" class="ctrl big">FIRE</div>
    <div id="btnFire2" class="ctrl">★</div>
  </div>
</div>

<!-- Pause overlay -->
<div id="pauseOverlay">
  <div class="panel">
    <h2>Paused</h2>
    <div style="margin-top:10px">
      <button id="resumeBtn" class="btn small">Resume</button>
      <button id="restartBtn" class="btn small">Restart</button>
    </div>
  </div>
</div>

<!-- Settings -->
<div id="settingsModal" style="display:none">
  <div style="font-weight:700;margin-bottom:8px">Settings</div>
  <label style="display:block;margin-bottom:8px">
    <input type="checkbox" id="soundToggle" checked> Sound
  </label>
  <label style="display:block;margin-bottom:8px">
    <input type="checkbox" id="musicToggle" checked> Music
  </label>
  <div style="margin-top:8px">
    <button id="closeSettings" class="btn small">Close</button>
  </div>
</div>

<div id="fps" style="display:none">FPS: 0</div>

<script>
/* =========================
   Shakrit — Full Single File
   No external assets required
   ========================= */

/* ---------- Config & State ---------- */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

let W = canvas.width, H = canvas.height;
let lastTs = 0, fps = 0, frameCount = 0, fpsTime = 0;

let game = {
  running:false,
  paused:false,
  level:1,
  score:0,
  lives:3,
  sound:true,
  music:true,
  difficulty:1
};

/* Input */
const Keys = { left:false, right:false, up:false, shoot:false, alt:false };

/* Entities */
let player, enemies = [], bullets = [], enemyBullets = [], particles = [], powerups = [];
let parallaxX = 0;

/* Audio using WebAudio (simple synth) */
let audioCtx = null;
function ensureAudio(){
  if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
}
function playSound(type, opts={}){
  if(!game.sound) return;
  ensureAudio();
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = opts.wave || 'square';
  o.frequency.value = opts.freq || (type==='shoot'?1200: (type==='hit'?200:440));
  g.gain.value = opts.gain || 0.03;
  o.connect(g); g.connect(audioCtx.destination);
  o.start();
  o.stop(audioCtx.currentTime + (opts.time || 0.06));
}

/* Background music simple loop */
let musicOsc=null;
function startMusic(){
  if(!game.music) return;
  ensureAudio();
  if(musicOsc) return;
  musicOsc = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  musicOsc.type = 'sine';
  musicOsc.frequency.value = 100;
  g.gain.value = 0.004;
  musicOsc.connect(g); g.connect(audioCtx.destination);
  musicOsc.start();
}
function stopMusic(){
  if(musicOsc){ musicOsc.stop(); musicOsc.disconnect(); musicOsc=null; }
}

/* ---------- Utilities ---------- */
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function rand(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }

/* ---------- Player drawing (simple pixel character) ---------- */
function drawPlayerShape(x,y,w,h,face,anim){
  // body
  ctx.save();
  ctx.translate(x,y);
  // shadow
  ctx.fillStyle = 'rgba(0,0,0,0.25)';
  ctx.fillRect(6+h*0.05, h-6, w-12, 8);
  // body
  ctx.fillStyle = '#2bb673';
  ctx.fillRect(0,0,w,h);
  // helmet
  ctx.fillStyle = '#0d6b4b';
  ctx.fillRect(0,0,w,Math.floor(h*0.28));
  // eye
  ctx.fillStyle = '#000';
  if(face==='right') ctx.fillRect(Math.floor(w*0.65), Math.floor(h*0.28), Math.floor(w*0.12), Math.floor(h*0.12));
  else ctx.fillRect(Math.floor(w*0.15), Math.floor(h*0.28), Math.floor(w*0.12), Math.floor(h*0.12));
  // gun
  ctx.fillStyle = '#333';
  if(face==='right'){
    ctx.fillRect(w, Math.floor(h*0.38), Math.floor(w*0.7), Math.floor(h*0.18));
  } else {
    ctx.fillRect(-Math.floor(w*0.7), Math.floor(h*0.38), Math.floor(w*0.7), Math.floor(h*0.18));
  }
  ctx.restore();
}

/* ---------- Entity factories ---------- */
function createPlayer(){
  return {
    x:120, y:H-120, w:44, h:56, vx:0, vy:0, onGround:true, facing:'right',
    anim:0, shootCooldown:0
  };
}
function spawnEnemy(type='grunt'){
  const e = {
    type, x: W + rand(30,240), y:H-110, w:44, h:48, vx: 1.2 + Math.random()*1.6,
    hp: type==='grunt'?1:10, shootTimer: rand(80,240)
  };
  if(type==='jumper'){ e.vx = 0.6 + Math.random()*1.2; e.jump = true; }
  enemies.push(e);
}
function spawnBoss(){
  const b = { type:'boss', x: W+40, y:H-220, w:160, h:160, vx:0.9, hp:60, phase:0, timer:0 };
  enemies.push(b);
}
function spawnPowerup(kind, x, y){
  powerups.push({ kind, x, y, w:22, h:22, vy:-2, life:600 });
}

/* ---------- Game init ---------- */
function resetGame(){
  player = createPlayer();
  enemies = [];
  bullets = [];
  enemyBullets = [];
  particles = [];
  powerups = [];
  parallaxX = 0;
  game.score = 0;
  game.lives = 3;
  game.level = 1;
  updateHUD();
}

/* ---------- HUD ---------- */
const scorePanel = document.getElementById('scorePanel');
const lifePanel = document.getElementById('lifePanel');
const levelPanel = document.getElementById('levelPanel');
function updateHUD(){
  scorePanel.textContent = 'Score: ' + game.score;
  lifePanel.textContent = 'Lives: ' + game.lives;
  levelPanel.textContent = 'Level: ' + game.level;
}

/* ---------- Physics & collisions ---------- */
function rects(a,b){
  return !(a.x + a.w < b.x || a.x > b.x + b.w || a.y + a.h < b.y || a.y > b.y + b.h);
}

/* ---------- Particle system ---------- */
function spawnExplosion(x,y,color,count=12){
  for(let i=0;i<count;i++){
    particles.push({
      x, y,
      vx: (Math.random()-0.5)*6,
      vy: (Math.random()-0.5)*6 - 1,
      life: 40 + rand(0,30),
      col: color || '#ffb86b'
    });
  }
}

/* ---------- Update loop ---------- */
function update(dt){
  // parallax scroll
  parallaxX -= 0.8 * game.difficulty;
  if(parallaxX < -W) parallaxX = 0;

  // player input
  const spd = 3.8 + game.difficulty*0.2;
  player.vx = 0;
  if(Keys.left){ player.vx = -spd; player.facing='left'; }
  if(Keys.right){ player.vx = spd; player.facing='right'; }
  if(Keys.up && player.onGround){ player.vy = -12.6; player.onGround=false; playSound('jump',{freq:600}); }
  // apply motion
  player.x += player.vx;
  player.vy += 0.6;
  player.y += player.vy;
  // ground
  if(player.y + player.h >= H - 20){ player.y = H - 20 - player.h; player.vy = 0; player.onGround = true; }
  // clamp to screen
  player.x = clamp(player.x, 8, W - player.w - 8);

  // shooting
  if(Keys.shoot && player.shootCooldown <= 0){
    // main bullet
    const bx = player.facing==='right' ? player.x + player.w + 4 : player.x - 12;
    bullets.push({ x:bx, y:player.y + player.h*0.45, vx: player.facing==='right'?12:-12, w:10, h:4, life:120 });
    player.shootCooldown = 10; // frames cooldown
    playSound('shoot',{freq:1200, time:0.04});
  }
  if(player.shootCooldown > 0) player.shootCooldown--;

  // update bullets
  for(let i=bullets.length-1;i>=0;i--){
    const b = bullets[i]; b.x += b.vx; b.life--;
    if(b.life<=0 || b.x < -50 || b.x > W+50) bullets.splice(i,1);
  }

  // enemies spawn & update
  if(Math.random() < 0.02 + 0.003 * game.difficulty) {
    const type = Math.random()<0.12 ? 'jumper' : 'grunt';
    spawnEnemy(type);
  }
  // level boss spawn condition
  if(game.level>0 && game.level%4 === 0 && enemies.filter(e=>e.type==='boss').length===0 && Math.random()<0.01){
    spawnBoss();
  }

  for(let i=enemies.length-1;i>=0;i--){
    const e = enemies[i];
    if(e.type==='boss'){
      e.timer++;
      // simple boss AI: hover, shoot patterns
      e.x -= e.vx;
      if(e.x < W - 420) e.x = W - 420;
      e.timer++;
      if(e.timer % 80 === 0){
        // shoot several bullets
        for(let k=-2;k<=2;k++){
          enemyBullets.push({ x:e.x + e.w/2, y:e.y + e.h/2, vx: -4 + k*0.8, vy: (k*0.5), w:8, h:6, life:180 });
        }
      }
    } else {
      // grunt or jumper
      e.x -= e.vx * (1 + game.difficulty*0.1);
      if(e.type==='jumper' && Math.random()<0.006 && e.y === H - 110) {
        e.vy = -10 - Math.random()*6;
      }
      // remove off-screen
      if(e.x + e.w < -80) enemies.splice(i,1);
      // occasionally fire
      if(Math.random() < 0.003 + 0.001*game.difficulty){
        enemyBullets.push({ x:e.x, y:e.y + e.h*0.5, vx:-4, vy:0, w:8, h:6, life:200 });
      }
    }
    // enemy gravity for jumper
    if(e.vy !== undefined){
      e.vy = (e.vy||0) + 0.6;
      e.y += e.vy;
      if(e.y + e.h >= H - 20){ e.y = H - 20 - e.h; e.vy = 0; }
    }
  }

  // check bullet hit enemy
  for(let i=enemies.length-1;i>=0;i--){
    for(let j=bullets.length-1;j>=0;j--){
      if(rects(enemies[i], bullets[j])){
        enemies[i].hp -= 1;
        bullets.splice(j,1);
        playSound('hit',{freq:240});
        spawnExplosion(enemies[i].x + enemies[i].w/2, enemies[i].y + enemies[i].h/2, '#ffb86b', 8);
        if(enemies[i].hp <= 0){
          game.score += (enemies[i].type==='boss'?500:50);
          updateHUD();
          // drop power-up sometimes
          if(Math.random() < 0.12) spawnPowerup('life', enemies[i].x, enemies[i].y);
          enemies.splice(i,1);
          break;
        }
      }
    }
  }

  // enemy bullets -> player
  for(let i=enemyBullets.length-1;i>=0;i--){
    const b = enemyBullets[i];
    b.x += b.vx; b.y += b.vy; b.life--;
    if(b.life<=0) enemyBullets.splice(i,1);
    else if(rects(b, player)){
      enemyBullets.splice(i,1);
      hurtPlayer();
    }
  }

  // player -> enemy collision (touch)
  for(let i=enemies.length-1;i>=0;i--){
    if(rects(player, enemies[i])){
      // simple: kill enemy and damage player
      spawnExplosion(player.x + player.w/2, player.y + player.h/2, '#ff6b6b', 12);
      enemies.splice(i,1);
      hurtPlayer();
      break;
    }
  }

  // particles
  for(let i=particles.length-1;i>=0;i--){
    const p = particles[i];
    p.x += p.vx; p.y += p.vy; p.vy += 0.18; p.life--;
    if(p.life<=0) particles.splice(i,1);
  }

  // powerups update & pickup
  for(let i=powerups.length-1;i>=0;i--){
    const p = powerups[i];
    p.y += p.vy; p.vy += 0.15; p.life--;
    if(rects(player,p)){
      if(p.kind==='life'){ game.lives++; updateHUD(); playSound('power',{freq:900}); }
      powerups.splice(i,1);
    } else if(p.life<=0) powerups.splice(i,1);
  }

  // update HUD occasionally
  if(Math.random()<0.02) updateHUD();
}

/* ---------- Hurt & player death ---------- */
function hurtPlayer(){
  game.lives--;
  updateHUD();
  playSound('hit',{freq:160});
  spawnExplosion(player.x + player.w/2, player.y + player.h/2, '#ff4d4d', 12);
  // reset player position
  player.x = 120; player.y = H - 120; player.vy = 0;
  if(game.lives <= 0){
    // game over
    pauseGame();
    setTimeout(()=>{ alert('Game Over! Score: ' + game.score); }, 60);
  }
}

/* ---------- Render loop ---------- */
function render(){
  // background layer
  ctx.clearRect(0,0,W,H);
  // parallax sky
  ctx.fillStyle = '#071019';
  ctx.fillRect(0,0,W,H);
  // tiled parallax hills
  drawParallax();

  // ground
  ctx.fillStyle = '#132025';
  ctx.fillRect(0, H-20, W, 20);

  // powerups
  for(const p of powerups){
    ctx.fillStyle = '#ffd166';
    ctx.fillRect(p.x, p.y, p.w, p.h);
    ctx.fillStyle='#111';
    ctx.fillRect(p.x+4, p.y+4, p.w-8, p.h-8);
  }

  // enemies
  for(const e of enemies){
    ctx.fillStyle = e.type==='boss'? '#d81b60' : '#ff6b6b';
    ctx.fillRect(e.x, e.y, e.w, e.h);
    // HP bar for boss
    if(e.type==='boss'){
      ctx.fillStyle = '#222';
      ctx.fillRect( e.x, e.y - 8, e.w, 6 );
      const pct = e.hp / 60;
      ctx.fillStyle = '#00e676';
      ctx.fillRect(e.x, e.y - 8, e.w * pct, 6);
    }
  }

  // bullets
  ctx.fillStyle = '#ffd24d';
  for(const b of bullets) ctx.fillRect(b.x, b.y, b.w, b.h);

  // enemy bullets
  ctx.fillStyle = '#ff7b7b';
  for(const b of enemyBullets) ctx.fillRect(b.x, b.y, b.w, b.h);

  // player
  drawPlayerShape(player.x, player.y, player.w, player.h, player.facing, player.anim);

  // particles
  for(const p of particles){
    ctx.fillStyle = p.col; ctx.fillRect(p.x, p.y, 3, 3);
  }

  // HUD overlays (drawn on canvas as backup)
  // (DOM HUD already exists)
}

/* ---------- Parallax drawing ---------- */
function drawParallax(){
  // repeating simple hills
  for(let i=0;i<3;i++){
    const x = ((parallaxX*0.3) + i*W) % (W*3) - W;
    ctx.fillStyle = ['#0c3b2e','#0b2f26','#07261e'][i];
    ctx.beginPath();
    ctx.ellipse(x + W*0.5, H - 60 - i*20, W*0.8, 120, 0, 0, Math.PI*2);
    ctx.fill();
  }
}

/* ---------- Main loop ---------- */
function tick(ts){
  if(!lastTs) lastTs = ts;
  const dt = (ts - lastTs) / 16.666;
  lastTs = ts;

  // FPS calc
  frameCount++; fpsTime += (ts - (lastTs || ts));
  // update / render
  if(game.running && !game.paused){
    update(dt);
    render();
  }
  // schedule
  requestAnimationFrame(tick);
}

/* ---------- Controls & UI ---------- */
const startBtn = document.getElementById('startBtn');
const settingsBtn = document.getElementById('settingsBtn');
const creditsBtn = document.getElementById('creditsBtn');
const pauseOverlay = document.getElementById('pauseOverlay');
const resumeBtn = document.getElementById('resumeBtn');
const restartBtn = document.getElementById('restartBtn');
const settingsModal = document.getElementById('settingsModal');
const closeSettings = document.getElementById('closeSettings');
const soundToggle = document.getElementById('soundToggle');
const musicToggle = document.getElementById('musicToggle');

startBtn.onclick = ()=>{
  document.getElementById('title').style.display = 'none';
  canvas.style.display = 'block';
  // start audio on first user gesture
  ensureAudio(); if(game.music) startMusic();
  resetGame();
  game.running=true; game.paused=false;
  // initial enemy wave
  for(let i=0;i<3;i++) spawnEnemy();
};

settingsBtn.onclick = ()=> {
  settingsModal.style.display = 'block';
};
closeSettings.onclick = ()=> { settingsModal.style.display = 'none'; };
soundToggle.onchange = (e)=>{ game.sound = e.target.checked; };
musicToggle.onchange = (e)=>{ game.music = e.target.checked; if(!game.music) stopMusic(); else startMusic(); };

creditsBtn.onclick = ()=> {
  alert('Shakrit — built with ❤️ by you + ChatGPT.\nControls: Arrow keys or on-screen buttons. Press Z to shoot.');
};

resumeBtn.onclick = ()=>{ game.paused=false; pauseOverlay.style.display='none'; };
restartBtn.onclick = ()=>{ resetGame(); pauseOverlay.style.display='none'; game.paused=false; };

function pauseGame(){ game.paused = true; pauseOverlay.style.display='flex'; }

/* keyboard support */
window.addEventListener('keydown', (e)=>{
  if(e.key==='ArrowLeft') Keys.left = true;
  if(e.key==='ArrowRight') Keys.right = true;
  if(e.key===' ' || e.key==='ArrowUp') Keys.up = true;
  if(e.key.toLowerCase()==='z') Keys.shoot = true;
  if(e.key.toLowerCase()==='p'){ if(game.paused) resumeBtn.onclick(); else pauseGame(); }
});
window.addEventListener('keyup', (e)=>{
  if(e.key==='ArrowLeft') Keys.left = false;
  if(e.key==='ArrowRight') Keys.right = false;
  if(e.key===' ' || e.key==='ArrowUp') Keys.up = false;
  if(e.key.toLowerCase()==='z') Keys.shoot = false;
});

/* touch button wiring */
function wireTouch(id, keyName, hold=false){
  const el = document.getElementById(id);
  el.addEventListener('touchstart', (ev)=>{ ev.preventDefault(); if(hold) Keys[keyName]=true; else Keys[keyName]=true; }, {passive:false});
  el.addEventListener('touchend', (ev)=>{ ev.preventDefault(); if(hold) Keys[keyName]=false; else Keys[keyName]=false; }, {passive:false});
  // also allow mouse for testing
  el.addEventListener('mousedown', ()=>Keys[keyName]=true);
  el.addEventListener('mouseup', ()=>Keys[keyName]=false);
  el.addEventListener('mouseleave', ()=>Keys[keyName]=false);
}
wireTouch('btnLeft','left',true);
wireTouch('btnRight','right',true);
wireTouch('btnJump','up',false);
wireTouch('btnFire1','shoot',false);
wireTouch('btnFire2','shoot',false);

/* ---------- Start animation frame loop ---------- */
requestAnimationFrame(tick);

/* Resize handling */
function handleResize(){
  // Keep canvas resolution stable, but ensure fits in view
  const wrap = document.getElementById('canvasWrap');
  const maxW = Math.min(window.innerWidth - 36, 1000);
  const aspect = W / H;
  const newW = Math.floor(maxW);
  const newH = Math.floor(newW / aspect);
  canvas.style.width = newW + 'px';
  canvas.style.height = newH + 'px';
}
window.addEventListener('resize', handleResize);
handleResize();

/* Start paused (show title). Ensure HUD hidden if not started */
canvas.style.display='none';
updateHUD();

</script>
</body>
</html>
